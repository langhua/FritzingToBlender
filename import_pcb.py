bl_info = {
    "name": "Generate Fritzing PCB Model",
    "author": "Christopher S. Francis, Shi Jinghai",
    "version": (1, 0),
    "blender": (4, 21, 3),
    "location": "",
    "description": "Imports layers from a Gerber file package in SVG form and generates a model of the given PCB to allow for 3D inspection before ordering",
    "warning": "",
    "wiki_url": "",
    "category": "Add PCB Object",
}


##
# @mainpage
# @section description Description
# This module contains methods to import svg file exports from a collection of Gerber files and automatically turns the imports into a 3D model of the PCB in Blender.\n
# For putting it together and only testing so far, the PCB was designed using EasyEDA online circuit editing software. The exported Gerber files were opened in gerbv Gerber Viewer software, from which the SVG files were exported. The components of the model will be named identical to the SVG files.
# @section Example
# Here are some pictures of example files generated by this plug-in. The first couple are of the resultant board models, one as produced and one with a couple layers turned off. The second set shows the generated board models used with components downloaded from GrabCad.com or modeled myself.\n
# <IMG src="../images/screenshot1.png">
# <IMG src="../images/screenshot2.png">\n
# <IMG src="../images/screenshot3.png">
# <IMG src="../images/screenshot4.png">\n
#\n\n
# Here is a sample output of create_pcb_view.py.\n
# @htmlonly
# <iframe src="../images/pcb.html" width="700" height="300">
# </iframe>
# @endhtmlonly
# @section Author
# Developed By: Christopher S. Francis 25 June 2020 to ...


import bpy 
from mathutils import Vector
from bpy_extras.io_utils import ImportHelper
from bpy.types import Operator
from bpy.props import StringProperty
from mathutils import Matrix

from io_curve_svg.svg_util import (units,
                       read_float)
# import xml.etree.ElementTree as ET
from lxml import etree
import winsound
import os
import glob

# from decimal import Decimal
# from pcb_tools.rs274x import GerberFile
# from pcb_tools.excellon import ExcellonFile
# from pcb_tools import read as read_file
# from pcb_tools.layers import load_layer
# from pcb_tools.render.cairo_backend import GerberCairoContext

skipLayers = ['internal', 'topmask', 'bottommask', 'toppaste', 'bottompaste', 'unkown']

fritzingPcbCollectionName = 'frizting_pcb'

##
# The ImportPCB class is actually just the file dialog box which has to be an object in the current API when this was written (bpy 2.8.3)\n
class ImportPCB(Operator, ImportHelper):
    bl_idname = "pcb.import_svg"
    bl_label = "Import Friting PCB svg Folder"
    
    filename_ext = "."
    use_filter_folder = True
    
    def execute(self, context):
        directory = self.properties['filepath']
        cut = directory.rindex(os.path.sep[0])
        directory = directory[0:cut]
        tmp_filenames = glob.glob(os.path.join(directory, '*.svg'))
        # get filenames dictionary contains outline, bottom, top, bottomsilk, topsilk, drill
        filenames = dict()
        for filename in tmp_filenames:
            if filename.endswith('.gm1.svg'):
                filenames['outline'] = filename
            elif filename.endswith('.gbl.svg'):
                filenames['bottom'] = filename
            elif filename.endswith('.gtl.svg'):
                filenames['top'] = filename
            elif filename.endswith('_drill.txt.svg'):
                filenames['drill'] = filename
            elif filename.endswith('.gbo.svg'):
                filenames['bottomsilk'] = filename
            elif filename.endswith('.gto.svg'):
                filenames['topsilk'] = filename
        print('--1--' + str(filenames))

        try:
            # import svg files as pcb layers
            svgLayers = dict()
            # for file in filenames:
            #     if not file.endswith('.xy'):
            #         # gerber file
            #         layerClass, layer = load_gerber(directory, file)
            #         if layer:
            #             svgLayers[layerClass] = layer

            # import outline svg first to get width and height of pcb board
            layer = import_svg(layerClass='outline', file=filenames['outline'])
            if layer is None:
                raise FileNotFoundError('No outline svg(.gm1.svg) found.')
            else:
                svgLayers['outline'] = layer
            for layerClass, filename in filenames.items():
                print('--1.1--' + layerClass + '--' + filename)
                if layerClass != 'outline':
                    layer = import_svg(layerClass=layerClass, file=filename)
                    if layer is not None:
                        svgLayers[layerClass] = layer

            # remove extra verts
            bpy.ops.object.select_all(action="SELECT")
            for layerClass, layer in svgLayers.items():
                print('--10--')
                if layerClass != 'drill':
                    removeExtraVerts(layer)

            extrudeLayers(svgLayers, None, None, None, None)
            
            drill_layer = None
            for layerClass, layer in svgLayers.items():
                print('--11--')
                if layerClass == "outline":
                    create_material(layer, layerClass, (0.062, 0.296, 0.020, 0.99), 0.234, 0.235, 0.202)
                elif layerClass == 'bottomsilk':
                    create_material(layer, layerClass, (100, 100, 100, 1.0), 1, 0.5, 0.2)
                    # create_material(layer, layerClass, (0.062, 0.296, 0.020, 0.99), 0.234, 0.235, 0.202)
                elif layerClass == "bottom":
                    create_material(layer, layerClass, (255, 180, 0, 1.0), 1, 0.5, 0.2)
                elif layerClass == "top":
                    create_material(layer, layerClass, (255, 180, 0, 1.0), 1, 0.5, 0.2)
                elif layerClass == "topsilk":
                    create_material(layer, layerClass, (100, 100, 100, 1.0), 1, 0.5, 0.2)
                elif layerClass == 'drill':
                    drill_layer = layer

            # drill holes
            if drill_layer and svgLayers:
                print('--12--')
                for layerClass, layer in svgLayers.items():
                    if layerClass != 'drill':
                        drillHoles(layer, drill_layer)

            # remove drill holes collection
            svgLayers.pop('drill')
            for obj in drill_layer.objects:
                bpy.data.objects.remove(obj, do_unlink=True)
            bpy.data.collections.remove(drill_layer)
            
            # join the layers except holes_layer
            joinedLayer = None
            if svgLayers:
                print('--13--')
                bpy.ops.object.select_all(action="DESELECT")
                for layerClass, layer in svgLayers.items():
                    layer.select_set(True)
                bpy.context.view_layer.objects.active = list(svgLayers.values())[0]
                bpy.ops.object.join()
                joinedLayer = bpy.context.view_layer.objects.active
                joinedLayer.name = 'JoinedLayer'
            
        except Exception as e:
            print('--exception: ' + str(e))
            bpy.ops.pcb.import_error("INVOKE_DEFAULT")

        # play a sound to notice user this long proceedure finished
        if os.name == 'nt':
            winsound.PlaySound(os.path.join('sound', 'completed.wav'), winsound.SND_FILENAME)

        return {"FINISHED"}


##
# Dialog box to handle error messages
class ErrorDialog(Operator):
    bl_idname = "pcb.import_error"
    bl_label = "Import PCB Error"

    text = StringProperty(name="An Error Occurred", default="Please Try Again")
    
    def execute(self, context):
        return {"FINISHED"}    
    
    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)

    
##
# Adds this class to the list the bpy module knows about, necessary to run it\n
# in later versions register it to whichever menu or panel it will be called from
def register():
    bpy.utils.register_class(ImportPCB)
    bpy.utils.register_class(ErrorDialog)


##
# Removes this class from the list the bpy module knows about 
def unregister():
    bpy.utils.unregister_class(ImportPCB)
    bpy.utils.unregister_class(ErrorDialog)
    

##
# Turns visibility off for all objects           
def hideAll():
    for layer in bpy.data.objects:
        layer.select_set(False)
        layer.hide_set(True) 


##
# Turns on all objects which are part of the PCB, this excludes the drill tool object
def revealAll():
    for layer in bpy.data.objects:
        layer.select_set(False)
        if layer.name == "drill":
            layer.hide_set(True)
        else:
            layer.hide_set(False)


##
# Brings in the SVG file, applies the x and y orientation, converts the curves to meshes, scales it to 1 millimeter in blender equals 1 millimeter in the real world, and places the objects into a collection ... \(still to come: extrusions, height placement, cut the holes, and join a copy into a completed version\)\n
# Uses Blender 4.2 or higher API
#
# @param layerClass - the layer class from pcb-tools
# @param dir - the directory where the files are located
# @param file - the list of SVG files representing the Gerber Files / PCB
#
# @return layer - the layer objct imported
#
def import_svg(layerClass: str, file: str):
    # 1. deselect all
    bpy.ops.object.select_all(action='DESELECT')

    # 2. import the svg file and get the new curves
    start_objs = bpy.data.objects[:]
    bpy.ops.import_curve.svg(filepath=file)
    print('--2.0--' + file)
    collectionName = file[file.rindex(os.path.sep[0]) + 1 :]
    print('--2.1--' + collectionName)
    bpy.data.collections[collectionName].name = fritzingPcbCollectionName + '_' + layerClass
    collectionName = fritzingPcbCollectionName + '_' + layerClass
    new_curves = [o for o in bpy.data.objects if o not in start_objs]
    print('--2.2--' + str(len(new_curves)))
    if not new_curves:
        return None

    # 3. transform new curves to mesh
    print('--3--')
    print(file)
    boardoutline = None
    for newCurve in new_curves:
        if bpy.data.curves[newCurve.name]:
            bpy.data.curves[newCurve.name].dimensions = '3D'
        if layerClass == 'outline':
            boardoutline = newCurve
        else:
            newCurve.select_set(True)

        if layerClass == 'drill':
            bpy.context.view_layer.objects.active = newCurve
            bpy.ops.object.convert(target="MESH")

    # 4. join the new curves into one by 2 steps
    print('--4--')
    if layerClass != 'drill':
        bpy.ops.object.select_all(action='DESELECT')
        objects = bpy.data.collections[collectionName].objects
        curves = []
        for obj in objects:
            bpy.context.view_layer.objects.active = obj
            active_object = bpy.context.active_object
            if obj != boardoutline and active_object.type == 'CURVE':
                obj.select_set(True)
                curves.append(obj)

        if len(curves) > 0:
            bpy.context.view_layer.objects.active = curves[0]
            bpy.ops.object.join()
        if boardoutline:
            if layerClass == 'outline':
                boardoutline.select_set(True)
                bpy.context.view_layer.objects.active = boardoutline
                bpy.ops.object.join()
            else:
                bpy.ops.object.select_all(action='DESELECT')
                boardoutline.select_set(True)
                bpy.context.view_layer.objects.active = boardoutline
                bpy.ops.object.delete(use_global=True)
                

    # 5. parse the svg file again to get right unit scale number
    print('--5--')
    # tree = ET.parse(file)
    # root = tree.getroot()
    root = None
    with open(file) as f:
        tree = etree.parse(f)
        root = tree.getroot()
    unitscale = 1.0
    unit = ''
    if root is not None and root.attrib['height'] is not None:
        raw_height = root.attrib['height']
        token, last_char = read_float(raw_height)
        unit = raw_height[last_char:].strip()

    if unit in ('cm', 'mm', 'in', 'pt', 'pc'):
        # convert units to BU:
        unitscale = units[unit] / 90 * 1000 / 39.3701
        # apply blender unit scale:
        unitscale = bpy.context.scene.unit_settings.scale_length / unitscale

    # 6. scale the new layer
    print('--6--')
    if unitscale != 1.0:
        mat_scale = Matrix.LocRotScale(None, None, (unitscale, unitscale, unitscale))
        if layerClass == 'drill':
            fileLayerObjects = bpy.data.collections[collectionName].objects
            for obj in  fileLayerObjects:
                obj.data.transform(mat_scale)
                obj.scale = 1, 1, 1
        else:
            bpy.context.view_layer.objects.active = bpy.data.collections[collectionName].objects[0]
            bpy.context.object.data.transform(mat_scale)
            bpy.context.object.scale = 1, 1, 1
    
    # 7. convert curves to MESH
    print('--7--')
    if layerClass != 'drill':
        objects = bpy.data.collections[collectionName].objects
        bpy.context.view_layer.objects.active = objects[0]
        for obj in objects:
            obj.select_set(True)
        bpy.ops.object.convert(target="MESH")
        # bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')

    # 8. add the imported pcb board layer to fritzing pcb layer
    print('--8--')
    layer = None
    if layerClass == 'drill':
        layer = bpy.data.collections[collectionName]
    else:
        layer = bpy.context.selected_objects[0]
        layer.name = collectionName

    print('--8.1--')
    # 8.2 add layer to the top pcb collection
    if fritzingPcbCollectionName not in bpy.data.collections:
        if layerClass == 'drill':
            fritzingPcbCollection = bpy.data.collections.new(fritzingPcbCollectionName)
            fritzingPcbCollection.objects.link(layer)
        else:
            bpy.ops.object.move_to_collection(collection_index = 0, is_new = True, new_collection_name=fritzingPcbCollectionName)
    else:
        if layerClass == 'drill':
            newLayer = bpy.data.collections.new('drill')
            for obj in layer.all_objects:
                newLayer.objects.link(obj)
            bpy.data.collections[fritzingPcbCollectionName].children.link(newLayer)
            layer = newLayer
        else:
            bpy.data.collections[fritzingPcbCollectionName].objects.link(layer)

    # 9. remove the orignal collection named by file
    print('--9--')
    col = bpy.data.collections[collectionName]
    if col:
        bpy.data.collections.remove(col)
    col = bpy.data.collections[fritzingPcbCollectionName]
    if col:
        for obj in col.objects:
            obj.select_set(False)
    
    # 10. return the layer
    return layer


# def load_gerber(dir, file):
#     try:
#         # get gerber file and layer class
#         layer = load_layer(os.path.join(dir, file))
#         gerberFile = read_file(os.path.join(dir, file))
#         if layer.layer_class not in skipLayers:
#             tmpdir = os.path.join(dir, 'svg')
#             if not os.path.exists(tmpdir):
#                 # make tmpdir
#                 os.makedirs(tmpdir, 0o755)
#             svgFilename = os.path.join(tmpdir, file + '.svg')
#             ctx = GerberCairoContext()
#             gerberFile.render(ctx=ctx, filename=svgFilename)
#             # print('--1--' + str(layer.layer_class))
#             return layer.layer_class, import_svg(layer.layer_class, tmpdir, os.path.basename(svgFilename), gerberFile.bounding_box[0][0], gerberFile.bounding_box[0][1])
#     except Exception as e:
#         print('-- exception: ' + str(e))

#     return None, None


##
# Removes the overlapping vertices on all layers
def removeExtraVerts(layer):
    bpy.context.view_layer.objects.active = layer
    bpy.ops.object.editmode_toggle()
    bpy.ops.mesh.select_mode(type="VERT")
    bpy.ops.mesh.select_all(action="SELECT")
    bpy.ops.mesh.remove_doubles()
    bpy.ops.mesh.select_all(action="DESELECT")
    bpy.ops.object.editmode_toggle()


##
# extrudes all components and sets the vertical position of each layer
def extrudeLayers(svgLayers, boardThickness, copperThickness, solderMaskThickness, silkscreenThickness):
    if not boardThickness or boardThickness < 4e-4:
        boardThickness = 0.0016         # 1.6mm
    if not copperThickness or copperThickness < 2.54e-5:
        # 1oz
        copperThickness = 2.54e-5
    if not solderMaskThickness or solderMaskThickness < 2e-5:
        # 0.8mils
        solderMaskThickness = 2e-5
    if not silkscreenThickness or silkscreenThickness < 2.54e-5:
        silkscreenThickness = 2.54e-5
    silkscreenLineWidth = 5 * silkscreenThickness
    bpy.ops.object.select_all(action="DESELECT")
    for layerClass, layer in svgLayers.items():
        if layerClass == "outline":
            bpy.context.view_layer.objects.active = layer
            bpy.ops.object.editmode_toggle()
            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.edge_face_add()
            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip":False, "mirror":False}, TRANSFORM_OT_translate={"value":Vector((0, 0, boardThickness))})
            bpy.ops.object.editmode_toggle()
            layer.location.z = 0
        elif layerClass == 'bottomsilk':
            bpy.context.view_layer.objects.active = layer
            bpy.ops.object.editmode_toggle()
            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip":False, "mirror":False}, TRANSFORM_OT_translate={"value":Vector((silkscreenLineWidth, silkscreenLineWidth, silkscreenThickness))})
            bpy.ops.object.editmode_toggle()
            layer.location.z = -silkscreenThickness/2
        elif layerClass == "bottom":
            bpy.context.view_layer.objects.active = layer
            bpy.ops.object.editmode_toggle()
            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip":False, "mirror":False}, TRANSFORM_OT_translate={"value":Vector((copperThickness, copperThickness, copperThickness/5))})
            bpy.ops.object.editmode_toggle()
            layer.location.z = - copperThickness/3
        elif layerClass == "top":
            bpy.context.view_layer.objects.active = layer
            bpy.ops.object.editmode_toggle()
            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip":False, "mirror":False}, TRANSFORM_OT_translate={"value":Vector((copperThickness, copperThickness, copperThickness/5))})
            bpy.ops.object.editmode_toggle()
            layer.location.z = boardThickness - 2 * copperThickness / 3
        elif layerClass == "topsilk":
            bpy.context.view_layer.objects.active = layer
            bpy.ops.object.editmode_toggle()
            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip":False, "mirror":False}, TRANSFORM_OT_translate={"value":Vector((silkscreenLineWidth, silkscreenLineWidth, silkscreenThickness))})
            bpy.ops.object.editmode_toggle()
            layer.location.z = boardThickness - silkscreenThickness/2
        elif layerClass == "drill":
            for obj in layer.objects:
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.editmode_toggle()
                bpy.ops.mesh.select_all(action="SELECT")
                bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"use_normal_flip":False, "mirror":False}, TRANSFORM_OT_translate={"value":Vector((0, 0, boardThickness + 2e-3))})
                bpy.ops.object.editmode_toggle()
                obj.location.z = -1e-3


##
# Generates a starting material \(base-color, mettalic, specular_intensity, and roughness\) for each of the layers of the PCB and applies said material\n
# @param object -the object to which the material will be applied
# @param name -string of a unique name for the material
# @param rgba -a tuple of floats representing the red-green-blue-alpha value for the base coloring
# @param metallic -a float for the percentage of metallic texture
# @param specular -a float for the percentage of specular-intensity \(reflected light\)
# @param roughness -a float for the percentage of roughness in the texture \(surface divisions for specular intensity\)
def create_material(layer, name="material_name", rgba=(0.0, 0.0, 0.0, 1.0), metallic=0.5, specular=0.5, roughness=0.5):
    # make sure computer thinks the mouse is in the right location, avoid ...poll() errors.
    for area in bpy.context.screen.areas: 
        if area.type == "VIEW_3D":
            for space in area.spaces: 
                if space.type == "VIEW_3D":
                    space.shading.type = "MATERIAL"

    bpy.context.view_layer.objects.active = layer
    material = bpy.data.materials.new(name)
    material.diffuse_color = rgba
    material.metallic = metallic
    material.specular_intensity = specular
    material.roughness = roughness
    layer.data.materials.append(material)
                    
    for area in bpy.context.screen.areas: 
        if area.type == "VIEW_3D":
            for space in area.spaces: 
                if space.type == "VIEW_3D":
                    space.shading.type = "SOLID"


##
# Applies a thickness to the 2d \(extruded along z by this point\) curves representing the traces for the top and bottom layer in the PCB
# @param layer -string name of the layer of the board to apply modifier to
# @param thickness -the width of the trace in the design
def solidify(layer, thickness):
    for area in bpy.context.screen.areas: 
        if area.type == "VIEW_3D":
            for space in area.spaces: 
                if space.type == "VIEW_3D":
                    space.shading.type = "SOLID"

    modifier = layer.modifiers.new(name="Solidify", type="SOLIDIFY")
    modifier.thickness = thickness
    bpy.context.view_layer.objects.active = layer
    bpy.ops.object.modifier_apply(modifier="Solidify")


##
# creates a drill hole through an individual layer of the pcb
# @param layer_name -the layer to drill the holes in
def drillHoles(layer, drill_layer):
    for area in bpy.context.screen.areas: 
        if area.type == "VIEW_3D":
            for space in area.spaces: 
                if space.type == "VIEW_3D":
                    space.shading.type = "SOLID"

    if layer and drill_layer:
        for obj in drill_layer.objects:
            modifier = layer.modifiers.new(name="Boolean", type="BOOLEAN")
            modifier.object = obj
            bpy.context.view_layer.objects.active = layer
            bpy.ops.object.modifier_apply(modifier="Boolean")


##
# Duplicates all component layers in the pcb and joins them into a single object. It then moves this object out of the layers collection and into the primary collection. The single board is placed at the origin with a geometry-centralized local origin and the layered board is moved off to the side
def harden():
    revealAll()

    for area in bpy.context.screen.areas: 
        if area.type == "VIEW_3D":
            for space in area.spaces: 
                if space.type == "VIEW_3D":
                    space.shading.type = "SOLID"

    bpy.ops.object.select_all(action="SELECT")
    bpy.ops.object.duplicate_move()
    bpy.ops.object.join()
    bpy.ops.object.origin_set(type="ORIGIN_GEOMETRY", center="MEDIAN")
    board = bpy.context.selected_objects[0]
    board.name = "PCB"
    bpy.data.collections["Collection"].objects.link(board)
    board.location = (0, 0, 0)
    bpy.ops.collection.objects_remove_active(collection="layers")
    for layer in bpy.data.objects:
        if layer.name != "PCB":
            layer.location.x += 100


# run the script
if __name__ == "__main__":
    register()
    